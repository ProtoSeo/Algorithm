/*
문제
NASA에서는 화성 탐사를 위해 화성에 무선 조종 로봇을 보냈다. 
실제 화성의 모습은 굉장히 복잡하지만, 로봇의 메모리가 얼마 안 되기 때문에 지형을 N×M 배열로 단순화 하여 생각하기로 한다.

지형의 고저차의 특성상, 로봇은 움직일 때 배열에서 왼쪽, 오른쪽, 아래쪽으로 이동할 수 있지만, 위쪽으로는 이동할 수 없다. 
또한 한 번 탐사한 지역(배열에서 하나의 칸)은 탐사하지 않기로 한다.

각각의 지역은 탐사 가치가 있는데, 로봇을 배열의 왼쪽 위 (1, 1)에서 출발시켜 오른쪽 아래 (N, M)으로 보내려고 한다. 
이때, 위의 조건을 만족하면서, 탐사한 지역들의 가치의 합이 최대가 되도록 하는 프로그램을 작성하시오.

입력
첫째 줄에 N, M(1≤N, M≤1,000)이 주어진다. 다음 N개의 줄에는 M개의 수로 배열이 주어진다. 배열의 각 수는 절댓값이 100을 넘지 않는 정수이다. 
이 값은 그 지역의 가치를 나타낸다.

출력
첫째 줄에 최대 가치의 합을 출력한다.
*/
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
int n,m, a[1001][1001],d[1001][1001];
int main(){
    ios::sync_with_stdio(false); cin.tie(NULL);
    int i,j;
    cin >> n >> m;
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){  //입력
            cin >> a[i][j];
        }
    }
    for(i=1;i<=m;i++){  //맨위칸은 오른쪽으로 가능경우밖에 존재하지 않으므로 그렇게 초기화 한다.
        d[1][i] += (a[1][i] + d[1][i-1]);
    }
    for(i=2;i<=n;i++){
        vector<int> goRight(m+2,0);    //왼쪽끝에서 오른쪽으로 가면서 최댓값을 구하는 경우
        vector<int> goLeft(m+2,0);    //오른쪽 끝에서 왼쪽으로 오면서 최댓값을 구하는 경우
        goRight[0]= d[i - 1][1];   //처음 초기값을 위층에서 바로 내려온 값으로 설정한다.
        for(j=1;j<=m;j++){  //위에서 내려오는 값 vs 왼쪽에서 오른쪽으로 이동하는 값 의 최댓값을 구한다.
            goRight[j] = (max(d[i-1][j],goRight[j-1])+a[i][j]);
        }
        goLeft[m + 1] = d[i - 1][m];    //처음 초기값을 위층에서 바로 내려온 값으로 설정한다.
        for(j=m;j>=1;j--){  //위에서 내려오는 값 vs 오른쪽에서 왼쪽으로 이동하는 값의 최댓값을 구한다.
            goLeft[j] = (max(d[i-1][j],goLeft[j+1])+a[i][j]);
        }
        for(j=1;j<=m;j++){  //두 배열 중에서 큰 값을 d배열에 저장한다.
            d[i][j] = max(goRight[j],goLeft[j]);
        }
    }
    cout<<d[n][m];
}